# 66. 加一

## 题目描述
给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
    
最高位数字存放在数组的首位，数组中每个元素只存储一个数字。
    
你可以假设除了整数0之外，这个整数不会以零开头。
    
示例 1:
```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```
示例 2:
```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```

## 解题思路
&#160; &#160; &#160; &#160;finally!功夫不负有心人呐！第一次自己尝试不靠任何外界帮助，用递归做出来了！不过还是遇到很多挫折，很多次的解答错误。现将方法和思路和试错过程记录一下。
	
&#160; &#160; &#160; &#160;首先，不能用数组变整数加一再变数组的方法（别问我是怎么知道的），因为给定的测试用例可能会大于INT_MAX。所以用递归思想是对的，但递归最关键的是结束条件。反之，在这道题中，关键在于**递归条件**。
    
&#160; &#160; &#160; &#160;我设置的是，有进位才递归。而进位的判断标准就是，当前位是否大于9，也就是说是否等于10。只有当前位等于9的时候加一才会产生进位。**一旦进入了递归函数，证明有进位**。所以判断当前位如果小于9，直接+1，结束递归；不然，判断是否到最高位了，如果是，则需要在首部添加1，当前位置0，结束递归；否则，当前位置零，前一位+1（进位），这里就是**最关键**的地方了！前面说到**有进位才递归**，所以要判断前一位是否产生进位，如果有，则递归，否则，结束递归。
    
&#160; &#160; &#160; &#160;可能说的还是有点乱，这些都是在试错过程中发现的，所以遇到这类问题要多测试，例如，9999，8999，9这样的特殊测试用例。

## 代码
```
class Solution {
public:
    void digui(vector<int>& digits,int pos)
    {
        if(digits[pos]<9)
            digits[pos]++;
        else if(pos==0)
        {
            digits[pos]=0;
            digits.insert(digits.begin(),1);
        }
        else
        {
            digits[pos]=0;
            digits[pos-1]++;
            if(digits[pos-1]>9)
                digui(digits,pos-1);//证明有进位
        }
    }
    vector<int> plusOne(vector<int>& digits) {
        if(digits[digits.size()-1]<9)
        {
            digits[digits.size()-1]++;
            return digits;
        }
        else if(digits.size()==1&&digits[0]==9)
        {
            digits[0]=0;
            digits.insert(digits.begin(),1);
        }
        else
            digui(digits,digits.size()-1);
        return digits;
    }
};
```