# 784. 字母大小写全排列

## 题目描述
给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。
    
示例:
```
输入: S = "a1b2"
输出: ["a1b2", "a1B2", "A1b2", "A1B2"]

输入: S = "3z4"
输出: ["3z4", "3Z4"]

输入: S = "12345"
输出: ["12345"]
```
注意：
    
1. S 的长度不超过12。

2. S 仅由数字和字母组成。

## 解题思路
&#160; &#160; &#160; &#160;这道题和全排列差不多，思想都是一样的。但是需要注意的是代码中**标注**的地方，如果遇到非字母字符，要继续递归下去。
    
&#160; &#160; &#160; &#160;并且，由于我是直接传递的S的引用，所以每一次修改字母之后要记得改回来，否则会出现一些奇怪的字符（别问我是怎么知道的）。
    
&#160; &#160; &#160; &#160;和全排列不同的是，由于我直接传递的S的引用，所以就不需要用for循环了，每一次递归i+1即可（全排列中设置了一个temp中间变量，用来记录每一次全排列的结果，并没有改变原数组）。递归结束条件是i等于S的长度，即扫描完毕。

## 代码
```
class Solution {
public:
    void DFS(vector<string> &ans,string S,int i)
    {
        if(i==S.length())
            ans.push_back(S);
        else
        {
            if(S[i]>=65&&S[i]<=90)
            {
                S[i]+=32;
                DFS(ans,S,i+1);
                S[i]-=32;
            }
            else if(S[i]>=97&&S[i]<=122)
            {
                S[i]-=32;
                DFS(ans,S,i+1);
                S[i]+=32;
            }
            DFS(ans,S,i+1);//标注
        }            
    }
    vector<string> letterCasePermutation(string S) {
        vector<string> ans;
        DFS(ans,S,0);
        return ans;
    }
};
```