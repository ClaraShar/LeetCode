# 70. 爬楼梯

## 题目描述
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
        
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
        
注意：给定 n 是一个正整数。
        
示例 1：
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```
示例 2：
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

## 解题思路
&#160; &#160; &#160; &#160;参考[解答](https://www.cnblogs.com/ariel-dreamland/p/9153960.html)
		
&#160; &#160; &#160; &#160;经思考发现又是一道类似斐波那契数列的题目。dp[n]=dp[n-1]+dp[n-2]，可采用递归思想。

&#160; &#160; &#160; &#160;但是由于递归计算了很多分支，效率很低，会超时，所以需要用动态规划来提高效率。
        
&#160; &#160; &#160; &#160;这位作者最巧妙的地方在于，可以只用两个整型变量a和b来存储过程值，首先将a+b的值赋给b，然后a赋值为原来的b，所以应该赋值为b-a即可。这样就模拟了上面累加的过程，而不用数组存储所有的值。
        
例如：
```
dp[n]=dp[n-1]+dp[n-2]
dp[n-1]=dp[n-2]+dp[n-3]
```
观察可发现，两式中有重复计算的地方。所以令a=dp[n-3],b=dp[n-2];b+=a;a=b-a。如果还不明白的同学可以把两式中的a、b区分一下命名，计算一下。

## 代码
```
class Solution {
public:
    int climbStairs(int n) {
        int a=1,b=1;
        while(n--)
        {
            b+=a;
            a=b-a;
        }
        return a;
    }
};
```