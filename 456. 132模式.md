# 456. 132模式

## 题目描述
给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。
        
注意：n 的值小于15000。
        
示例1:
```
输入: [1, 2, 3, 4]

输出: False

解释: 序列中不存在132模式的子序列。
```
示例 2:
```
输入: [3, 1, 4, 2]

输出: True

解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
```
示例 3:
```
输入: [-1, 3, 2, 0]

输出: True

解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
```
## 解题思路
&#160; &#160; &#160; &#160;我只能想到三个循环的方法，那肯定会超时。
    
&#160; &#160; &#160; &#160;看到有一个[博客](https://www.cnblogs.com/grandyang/p/6081984.html)用的栈的方法，这样的思想是我想不到的，受教了。由于博客已经说的很清楚了，我就不赘述了，感兴趣的可以自己点进去看。
    
&#160; &#160; &#160; &#160;其中最关键的一点是，**132的“2”值越大越好，因为这样才可以更容易的满足当前的值“1”比“2”值小这个条件**。
## 代码
```
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int third = INT_MIN;
        stack<int> s;
        for (int i=nums.size()-1;i>=0;--i)
        {
            if(nums[i]<third)
                return true;
            else
            {
                while(!s.empty()&&nums[i]>s.top())
                {
                    third=s.top();
                    s.pop();
                }
            }
            s.push(nums[i]);
        }
        return false;
    }
};
```