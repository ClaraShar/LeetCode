# 35. 搜索插入位置

## 题目描述
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
        
你可以假设数组中无重复元素。
        
示例 1:
```
输入: [1,3,5,6], 5
输出: 2
```
示例 2:
```
输入: [1,3,5,6], 2
输出: 1
```
示例 3:
```
输入: [1,3,5,6], 7
输出: 4
```
示例 4:
```
输入: [1,3,5,6], 0
输出: 0
```

## 解题思路
&#160; &#160; &#160; &#160;这道题本身并不难，我原本不想记录。但我今天比较关心执行用时的问题，所以看了一下用时最短的解答。
&#160; &#160; &#160; &#160;我发现循环当中前置++和后置++的效率差了很多！于是就查了一下，发现了这篇[博客](http://www.cnblogs.com/AndyJee/p/4550391.html)。
&#160; &#160; &#160; &#160;简单来说，如果是普通类型，效率没有差别，但leetcode是在类里面使用的，后置++多了一个保存临时对象的操作，所以性能会有所下降。

## 代码
```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();++i)
        {
            if(nums[i]>=target)
                return i; 
        }
        return nums.size();
    }
};
```